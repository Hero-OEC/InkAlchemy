# StoryForge - Worldbuilding Management Platform

## Overview

StoryForge is a comprehensive worldbuilding and story management platform designed for writers and creators. It provides tools to organize characters, locations, timelines, magic systems, lore, and notes within structured projects. The application uses a modern full-stack architecture with a React frontend and Express backend, leveraging PostgreSQL for data persistence.

## User Preferences

Preferred communication style: Simple, everyday language.
Typography: Cairo font for entire application with full weight range (200-900).
Design approach: Light mode only, custom brand color palette, offline-first architecture.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Build Tool**: Vite for development and production builds
- **UI Library**: Shadcn/ui components built on Radix UI primitives
- **Styling**: Tailwind CSS with CSS variables for theming
- **State Management**: TanStack Query (React Query) for server state management
- **Routing**: Wouter for lightweight client-side routing
- **Forms**: React Hook Form with Zod validation

### Backend Architecture
- **Runtime**: Node.js with Express.js framework
- **Language**: TypeScript with ES modules
- **Database ORM**: Drizzle ORM for type-safe database operations
- **Validation**: Zod schemas shared between frontend and backend
- **Development**: Hot reloading with Vite integration in development mode

### Project Structure
- `/client` - React frontend application
- `/server` - Express backend with API routes
- `/shared` - Shared TypeScript schemas and types
- `/migrations` - Database migration files (generated by Drizzle)

## Key Components

### Database Schema
The application uses a relational PostgreSQL database with the following core entities:
- **Projects**: Top-level containers for story worlds
- **Characters**: Character profiles with appearance, personality, background
- **Locations**: Geographical and structural locations with hierarchical relationships
- **Events**: Timeline events with ordering and importance levels
- **Magic Systems**: Supernatural systems with rules and limitations
- **Lore Entries**: World history and cultural information
- **Notes**: Quick notes with categorization and color coding
- **Relationships**: Character relationships and connections

### API Design
RESTful API endpoints following convention:
- `GET /api/projects/:id/[entity]` - List entities for a project
- `GET /api/[entity]/:id` - Get specific entity
- `POST /api/[entity]` - Create new entity
- `PATCH /api/[entity]/:id` - Update entity
- `DELETE /api/[entity]/:id` - Delete entity

### UI Architecture
- **Component Library**: Comprehensive set of reusable UI components (CharacterCard, Button variations, DeleteConfirmation, Navbar)
- **Typography**: Cairo font family with weights 200-900 for consistent visual hierarchy
- **Form Management**: Consistent form patterns with validation
- **Theme System**: Light mode only with custom brand color palette (brand-50 to brand-950)
- **Responsive Design**: Mobile-first approach with Tailwind breakpoints

## Data Flow

1. **Client Requests**: React components use TanStack Query hooks to fetch data
2. **API Layer**: Express routes handle HTTP requests and validate input with Zod
3. **Database Layer**: Drizzle ORM executes type-safe database queries
4. **Response Flow**: Data flows back through the same layers with automatic caching

### State Management Strategy
- **Server State**: TanStack Query manages all server data with automatic caching, background updates, and optimistic updates
- **Client State**: React useState and useContext for local component state
- **Form State**: React Hook Form for form-specific state management

## External Dependencies

### Core Dependencies
- **Database**: Neon Database (PostgreSQL) via `@neondatabase/serverless`
- **UI Components**: Radix UI primitives for accessible components
- **Validation**: Zod for runtime type checking and validation
- **Date Handling**: date-fns for date manipulation and formatting

### Development Dependencies
- **TypeScript**: Full TypeScript support across the stack
- **ESBuild**: Fast bundling for production builds
- **PostCSS**: CSS processing with Tailwind and Autoprefixer

### Database Configuration
- Uses environment variable `DATABASE_URL` for database connection
- Drizzle configured for PostgreSQL dialect with migrations in `/migrations`
- Session storage uses `connect-pg-simple` for PostgreSQL session store

## Deployment Strategy

### Development Mode
- Vite dev server serves the React application with HMR
- Express server runs with `tsx` for TypeScript execution
- Development-specific middleware for error overlays and debugging

### Production Build
- Frontend: Vite builds static assets to `/dist/public`
- Backend: ESBuild bundles server code to `/dist/index.js`
- Static file serving: Express serves built frontend assets in production

### Database Management
- Schema changes managed through Drizzle migrations
- `db:push` command for development schema synchronization
- Environment-based configuration for different deployment stages

### Replit Integration
- Configured for Replit deployment with runtime error handling
- Cartographer plugin for development environment debugging
- Replit-specific vite plugins for enhanced development experience

The architecture prioritizes developer experience with hot reloading, type safety, and modern tooling while maintaining production performance and scalability.

## Recent Changes

### January 2025 - Core Component System
- Implemented custom color palette system (brand-50 to brand-950) replacing default theme
- Created reusable CharacterCard component with image, type icons, badges, and metadata
- Built comprehensive Button component with 6 variants and 4 sizes
- Added DeleteConfirmation modal with backdrop blur and customizable content
- Developed responsive Navbar with conditional navigation based on project state
- Integrated Cairo font family with full weight range (200-900) for typography hierarchy
- Established light-mode-only design system with consistent visual language