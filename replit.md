# StoryForge - Worldbuilding Management Platform

## Overview

StoryForge is a comprehensive worldbuilding and story management platform designed for writers and creators. It provides tools to organize characters, locations, timelines, magic systems, lore, and notes within structured projects. The application uses a modern full-stack architecture with a React frontend and Express backend, leveraging PostgreSQL for data persistence.

## User Preferences

Preferred communication style: Simple, everyday language.
Typography: Cairo font for entire application with full weight range (200-900).
Design approach: Light mode only, custom brand color palette, offline-first architecture.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Build Tool**: Vite for development and production builds
- **UI Library**: Shadcn/ui components built on Radix UI primitives
- **Styling**: Tailwind CSS with CSS variables for theming
- **State Management**: TanStack Query (React Query) for server state management
- **Routing**: Wouter for lightweight client-side routing
- **Forms**: React Hook Form with Zod validation

### Backend Architecture
- **Runtime**: Node.js with Express.js framework
- **Language**: TypeScript with ES modules
- **Database ORM**: Drizzle ORM for type-safe database operations
- **Validation**: Zod schemas shared between frontend and backend
- **Development**: Hot reloading with Vite integration in development mode

### Project Structure
- `/client` - React frontend application
- `/server` - Express backend with API routes
- `/shared` - Shared TypeScript schemas and types
- `/migrations` - Database migration files (generated by Drizzle)

## Key Components

### Database Schema
The application uses a relational PostgreSQL database with the following core entities:
- **Projects**: Top-level containers for story worlds
- **Characters**: Character profiles with appearance, personality, background
- **Locations**: Geographical and structural locations with hierarchical relationships
- **Events**: Timeline events with ordering and importance levels
- **Magic Systems**: Supernatural systems with rules and limitations
- **Lore Entries**: World history and cultural information
- **Notes**: Quick notes with categorization and color coding
- **Relationships**: Character relationships and connections

### API Design
RESTful API endpoints following convention:
- `GET /api/projects/:id/[entity]` - List entities for a project
- `GET /api/[entity]/:id` - Get specific entity
- `POST /api/[entity]` - Create new entity
- `PATCH /api/[entity]/:id` - Update entity
- `DELETE /api/[entity]/:id` - Delete entity

### UI Architecture
- **Component Library**: Comprehensive set of reusable UI components (CharacterCard, Button variations, DeleteConfirmation, Navbar)
- **Typography**: Cairo font family with weights 200-900 for consistent visual hierarchy
- **Form Management**: Consistent form patterns with validation
- **Theme System**: Light mode only with custom brand color palette (brand-50 to brand-950)
- **Responsive Design**: Mobile-first approach with Tailwind breakpoints

## Data Flow

1. **Client Requests**: React components use TanStack Query hooks to fetch data
2. **API Layer**: Express routes handle HTTP requests and validate input with Zod
3. **Database Layer**: Drizzle ORM executes type-safe database queries
4. **Response Flow**: Data flows back through the same layers with automatic caching

### State Management Strategy
- **Server State**: TanStack Query manages all server data with automatic caching, background updates, and optimistic updates
- **Client State**: React useState and useContext for local component state
- **Form State**: React Hook Form for form-specific state management

## External Dependencies

### Core Dependencies
- **Database**: Neon Database (PostgreSQL) via `@neondatabase/serverless`
- **UI Components**: Radix UI primitives for accessible components
- **Validation**: Zod for runtime type checking and validation
- **Date Handling**: date-fns for date manipulation and formatting

### Development Dependencies
- **TypeScript**: Full TypeScript support across the stack
- **ESBuild**: Fast bundling for production builds
- **PostCSS**: CSS processing with Tailwind and Autoprefixer

### Database Configuration
- Uses environment variable `DATABASE_URL` for database connection
- Drizzle configured for PostgreSQL dialect with migrations in `/migrations`
- Session storage uses `connect-pg-simple` for PostgreSQL session store

## Deployment Strategy

### Development Mode
- Vite dev server serves the React application with HMR
- Express server runs with `tsx` for TypeScript execution
- Development-specific middleware for error overlays and debugging

### Production Build
- Frontend: Vite builds static assets to `/dist/public`
- Backend: ESBuild bundles server code to `/dist/index.js`
- Static file serving: Express serves built frontend assets in production

### Database Management
- Schema changes managed through Drizzle migrations
- `db:push` command for development schema synchronization
- Environment-based configuration for different deployment stages

### Replit Integration
- Configured for Replit deployment with runtime error handling
- Cartographer plugin for development environment debugging
- Replit-specific vite plugins for enhanced development experience

The architecture prioritizes developer experience with hot reloading, type safety, and modern tooling while maintaining production performance and scalability.

## Recent Changes

### January 2025 - Core Component System
- Implemented custom color palette system (brand-50 to brand-950) replacing default theme
- Created reusable CharacterCard component with image, type icons, badges, and metadata
- Built comprehensive Button component with 6 variants and 4 sizes
- Added DeleteConfirmation modal with backdrop blur and customizable content
- Developed responsive Navbar with conditional navigation based on project state
- Integrated Cairo font family with full weight range (200-900) for typography hierarchy
- Established light-mode-only design system with consistent visual language

### January 2025 - Timeline System Enhancement
- Built serpentine timeline component with visible connecting path using brand colors
- Implemented true responsive timeline with automatic breakpoint detection
- Added useResponsiveTimeline hook for screen size detection and layout adaptation
- Timeline adapts: Mobile (2 events/row, 320px), Tablet (3 events/row, 600px), Desktop (4 events/row, 1000px)
- Fixed container width issues and z-index layering for proper event display
- Added responsive prop to enable/disable automatic responsive behavior
- Supports both responsive mode and fixed-size override mode

### January 2025 - Multi-Event Timeline Functionality
- Implemented multi-event bubble display showing "X Events" for same-date events
- Created simplified multi-event hover popup with clickable individual event cards
- Added intelligent popup positioning to prevent viewport overflow
- Enhanced scroll detection to distinguish between timeline and popup scrolling
- Fixed internal popup scrolling while maintaining timeline scroll-to-close behavior
- Multi-event bubbles use brand-50 background with proper event count display

### January 2025 - Project Workspace Reset
- Cleared all project workspace pages (Dashboard, Characters, Locations, Timeline, Magic Systems, Lore)
- Each page now shows minimal clean template with proper navbar integration
- Maintained project-specific routing structure and project name display
- Ready for fresh content implementation with established component system

### January 2025 - Event Details Page Implementation
- Created comprehensive event details page with grid layout
- Added event header with icon, title, stage badge, type badge, and date badge
- Implemented main content area with event description in prose format
- Built sidebar with location and characters sections using MiniCard components
- Integrated clickable navigation to character and location detail pages
- Added proper routing for `/projects/:projectId/events/:eventId`
- Connected timeline event clicks to navigate to event details
- Applied consistent brand styling and 100px margin layout

### January 2025 - Event Form System Implementation
- Created comprehensive event form component supporting both create and edit modes
- Added dynamic header with real-time icon and color updates based on form selections
- Implemented complete form validation using Zod with event schema
- Built grid-based form layout with event type, stage, location, and date fields
- Integrated location selection dropdown with existing project locations
- Added proper routing for create (`/timeline/new-event`) and edit (`/events/:id/edit`) modes
- Connected edit button on event details page to form
- Added create event buttons to timeline page header and empty state
- Applied consistent brand styling and button variants throughout
- Implemented proper form reset and data loading for edit mode

### January 2025 - Character Management Enhancement
- Updated character management system with full CRUD operations (create, edit, details pages)
- Enhanced character schema with comprehensive fields (prefix, suffix, type, powerType, age, race)
- Standardized back button placement across all character pages following event form pattern
- Changed all back buttons to use "ghost" variant for consistent subtle appearance
- Added missing back button to character details page for complete navigation consistency
- Updated sample character data with complete field information for testing

### January 2025 - Notes Page Implementation
- Created notes page with same structure as other content pages (characters, events)
- Integrated ContentCard component for displaying notes with category-based icons
- Added support for note colors (yellow, blue, green, purple, pink, orange) with visual styling
- Implemented note category system (general, idea, reminder, plot, character, location, research)
- Added sample notes data to storage with diverse categories and colors for testing
- Connected routing for notes page at `/projects/:projectId/notes`
- Applied consistent page header with "Add Note" button placement
- Added empty state with appropriate call-to-action for creating first note